#!/usr/bin/env bash
# generate_and_push.sh
# Usage:
#   ./generate_and_push.sh [owner] [repo]
# Example:
#   ./generate_and_push.sh humayunlbb-lgtm college-management
#
# This script creates the entire monorepo file structure and content,
# validates essential files, initializes git, creates a GitHub repo via gh, and pushes.
# Requirements: gh (GitHub CLI) authenticated, git installed.
set -euo pipefail

OWNER="${1:-humayunlbb-lgtm}"
REPO="${2:-college-management}"
BRANCH="main"

echo "Owner: $OWNER"
echo "Repo:  $REPO"

if ! command -v git >/dev/null 2>&1; then
  echo "Error: git is not installed. Install git first."
  exit 1
fi

if ! command -v gh >/dev/null 2>&1; then
  echo "Error: gh (GitHub CLI) is not installed. Install it: https://cli.github.com/ and run 'gh auth login'"
  exit 1
fi

if ! gh auth status >/dev/null 2>&1; then
  echo "Error: gh CLI not authenticated. Run: gh auth login"
  exit 1
fi

# Create directories
mkdir -p prisma apps/frontend/pages apps/frontend/components apps/frontend/styles apps/frontend/utils apps/backend/src routes_tmp_ignore scripts apps/backend/src/routes apps/backend/src/controllers apps/backend/src/middleware apps/backend/src/services apps/backend/src/lib apps/backend/src/utils

echo "Creating files..."

# Root README.md
cat > README.md <<'EOF'
# College Management System — Monorepo

This repository contains a modern College Management System built with Next.js (frontend) and Node.js + Express + TypeScript (backend), using PostgreSQL with Prisma ORM.

Features (high level)
- Multi-role dashboard (Admin, Teacher, Student)
- Student portal (admissions, attendance, schedule, assignments, results)
- Teacher portal (class management, grading, attendance, messaging)
- Admin panel (user/role management, payments, events, security)
- Result generator (auto calculations + printable PDF)
- Library, hostel, and transport modules (structured)
- Online payments (Stripe example)
- Digital noticeboard + web push notifications
- Support chat (Socket.IO)
- AI Assistant panel (OpenAI integration)
- Quick actions, dark mode, voice search, exports (CSV/Excel/PDF)
- Auto backup & restore script
- Docker-ready + cloud deployment friendly (Vercel, AWS)

Quick start (dev)
1. Copy .env.example to .env at repo root and fill values.
2. Start PostgreSQL and Redis:
   - docker-compose up -d
3. Install dependencies:
   - pnpm install   (or npm install)
   - cd apps/frontend && pnpm install
   - cd ../backend && pnpm install
4. Generate Prisma client and seed DB:
   - cd prisma
   - pnpm install
   - pnpm prisma generate
   - pnpm ts-node seed.ts
5. Start backend:
   - cd apps/backend && pnpm run dev
6. Start frontend:
   - cd apps/frontend && pnpm run dev
7. Open http://localhost:3000

Deployment
- Backend: Dockerfile provided. Build and push; use managed DB & environment variables in production.
- Frontend: Deploy Next.js to Vercel / Netlify.
- Use environment variables (JWT_SECRET, DATABASE_URL, STRIPE_SECRET_KEY, OPENAI_API_KEY).

Security notes
- Hash passwords before seeding in production.
- Use HTTPS and secure cookies in production.
- Store secrets in a secure secrets manager.

License: MIT
EOF

# .env.example
cat > .env.example <<'EOF'
# Database (Postgres)
DATABASE_URL="postgresql://postgres:postgres@db:5432/college?schema=public"

# App
PORT=4000
FRONTEND_URL=http://localhost:3000
JWT_SECRET=replace-with-a-secure-random-string
JWT_EXPIRES_IN=7d

# Stripe (payments)
STRIPE_SECRET_KEY=sk_test_replace_me

# Web Push (VAPID keys)
VAPID_PUBLIC_KEY=your_public_vapid_key
VAPID_PRIVATE_KEY=your_private_vapid_key

# OpenAI
OPENAI_API_KEY=sk-...

# Prisma
NODE_ENV=development

# Backup
BACKUP_DIR=/backups
EOF

# docker-compose.yml
cat > docker-compose.yml <<'EOF'
version: "3.8"
services:
  db:
    image: postgres:15
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: college
    volumes:
      - db_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
  redis:
    image: redis:7
    ports:
      - "6379:6379"
volumes:
  db_data:
EOF

# root package.json
cat > package.json <<'EOF'
{
  "name": "college-management",
  "private": true,
  "workspaces": [
    "apps/*",
    "prisma"
  ],
  "scripts": {
    "dev": "concurrently \"pnpm --filter apps/backend dev\" \"pnpm --filter apps/frontend dev\"",
    "start:backend": "pnpm --filter apps/backend dev",
    "start:frontend": "pnpm --filter apps/frontend dev"
  },
  "devDependencies": {
    "concurrently": "^8.0.0",
    "pnpm": "^8.0.0"
  }
}
EOF

# prisma/schema.prisma
mkdir -p prisma
cat > prisma/schema.prisma <<'EOF'
generator client {
  provider = "prisma-client-js"
}
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  password  String
  name      String
  role      Role     @default(STUDENT)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  student   Student?
  teacher   Teacher?
}

model Student {
  id         Int      @id @default(autoincrement())
  user       User     @relation(fields: [userId], references: [id])
  userId     Int
  rollNumber String   @unique
  batch      String
  attendance Attendance[]
  results    Result[]
  createdAt  DateTime @default(now())
}

model Teacher {
  id        Int      @id @default(autoincrement())
  user      User     @relation(fields: [userId], references: [id])
  userId    Int
  subjects  String[]
  createdAt DateTime @default(now())
}

model Attendance {
  id         Int      @id @default(autoincrement())
  student    Student  @relation(fields: [studentId], references: [id])
  studentId  Int
  date       DateTime
  status     AttendanceStatus
  createdAt  DateTime @default(now())
}

model Exam {
  id         Int      @id @default(autoincrement())
  title      String
  date       DateTime
  maxMarks   Int
  createdAt  DateTime @default(now())
  results    Result[]
}

model Result {
  id        Int      @id @default(autoincrement())
  student   Student  @relation(fields: [studentId], references: [id])
  studentId Int
  exam      Exam     @relation(fields: [examId], references: [id])
  examId    Int
  marks     Int
  grade     String
  createdAt DateTime @default(now())
}

model Payment {
  id         Int      @id @default(autoincrement())
  studentId  Int
  amount     Float
  currency   String   @default("USD")
  method     String
  status     String
  reference  String   @unique
  createdAt  DateTime @default(now())
}

model Notice {
  id        Int      @id @default(autoincrement())
  title     String
  body      String
  audience  String
  createdAt DateTime @default(now())
}

enum Role {
  ADMIN
  TEACHER
  STUDENT
  STAFF
}

enum AttendanceStatus {
  PRESENT
  ABSENT
  LEAVE
}
EOF

# prisma/seed.ts
cat > prisma/seed.ts <<'EOF'
import { PrismaClient } from "@prisma/client";
import bcrypt from "bcrypt";

const prisma = new PrismaClient();

async function main() {
  // Create admin user with hashed password
  const adminPassword = await bcrypt.hash("Admin@1234", 10);
  const admin = await prisma.user.upsert({
    where: { email: "admin@college.edu" },
    update: {},
    create: {
      email: "admin@college.edu",
      password: adminPassword,
      name: "Admin User",
      role: "ADMIN",
    },
  });

  const studentPassword = await bcrypt.hash("Student@1234", 10);
  const studentUser = await prisma.user.upsert({
    where: { email: "student@college.edu" },
    update: {},
    create: {
      email: "student@college.edu",
      password: studentPassword,
      name: "Student User",
      role: "STUDENT",
    },
  });

  await prisma.student.upsert({
    where: { rollNumber: "S-2025-001" },
    update: {},
    create: {
      rollNumber: "S-2025-001",
      batch: "2025",
      userId: studentUser.id,
    },
  });

  console.log("Seeding complete.");
}
main()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
EOF

# apps/frontend files
mkdir -p apps/frontend/pages/dashboard apps/frontend/pages/api apps/frontend/components apps/frontend/styles apps/frontend/utils

cat > apps/frontend/package.json <<'EOF'
{
  "name": "college-frontend",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "dev": "next dev -p 3000",
    "build": "next build",
    "start": "next start -p 3000",
    "lint": "next lint"
  },
  "dependencies": {
    "next": "13.5.0",
    "react": "18.2.0",
    "react-dom": "18.2.0",
    "axios": "^1.3.0",
    "tailwindcss": "^3.4.0",
    "autoprefixer": "^10.4.14",
    "postcss": "^8.4.23",
    "heroicons-react": "^1.0.0"
  },
  "devDependencies": {
    "typescript": "^5.2.0"
  }
}
EOF

cat > apps/frontend/next.config.js <<'EOF'
/** @type {import('next').NextConfig} */
module.exports = {
  reactStrictMode: true,
  experimental: {
    appDir: false
  },
  env: {
    NEXT_PUBLIC_API_URL: process.env.NEXT_PUBLIC_API_URL || "http://localhost:4000",
  }
};
EOF

cat > apps/frontend/tailwind.config.js <<'EOF'
module.exports = {
  content: [
    "./pages/**/*.{js,ts,jsx,tsx}",
    "./components/**/*.{js,ts,jsx,tsx}"
  ],
  theme: {
    extend: {}
  },
  plugins: []
};
EOF

cat > apps/frontend/postcss.config.js <<'EOF'
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};
EOF

cat > apps/frontend/tsconfig.json <<'EOF'
{
  "compilerOptions": {
    "target": "ES2020",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "ESNext",
    "moduleResolution": "Node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "react-jsx"
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx"],
  "exclude": ["node_modules"]
}
EOF

cat > apps/frontend/pages/_app.tsx <<'EOF'
import '../styles/globals.css'
import type { AppProps } from 'next/app'
import { useEffect, useState } from 'react'

export default function App({ Component, pageProps }: AppProps) {
  const [theme, setTheme] = useState<'light'|'dark'>('light')

  useEffect(() => {
    const t = localStorage.getItem('theme') as 'light'|'dark' | null
    if (t) setTheme(t)
  }, [])

  useEffect(() => {
    document.documentElement.classList.toggle('dark', theme === 'dark')
    localStorage.setItem('theme', theme)
  }, [theme])

  return (
    <div className="min-h-screen bg-gray-50 dark:bg-gray-900 text-gray-900 dark:text-gray-50">
      <Component {...pageProps} setTheme={setTheme} theme={theme} />
    </div>
  )
}
EOF

cat > apps/frontend/pages/index.tsx <<'EOF'
import Link from 'next/link'

export default function Home() {
  return (
    <main className="container mx-auto p-6">
      <header className="flex items-center justify-between">
        <h1 className="text-3xl font-bold">College Management</h1>
        <nav>
          <Link href="/login" className="px-4 py-2 bg-blue-600 text-white rounded">Login</Link>
        </nav>
      </header>

      <section className="mt-8 grid grid-cols-1 md:grid-cols-2 gap-6">
        <div className="p-6 shadow rounded bg-white dark:bg-gray-800">
          <h2 className="text-xl font-semibold">Overview</h2>
          <p className="mt-2 text-sm">A modern, responsive portal for students, teachers and administrators.</p>
        </div>
        <div className="p-6 shadow rounded bg-white dark:bg-gray-800">
          <h2 className="text-xl font-semibold">AI Assistant</h2>
          <p className="mt-2 text-sm">Ask the AI panel for study tips, schedules, and procedural help.</p>
        </div>
      </section>
    </main>
  )
}
EOF

cat > apps/frontend/pages/login.tsx <<'EOF'
import { useState } from 'react'
import axios from 'axios'
import { useRouter } from 'next/router'
import LoginForm from '../components/LoginForm'

export default function Login() {
  const router = useRouter()
  const [error,setError]=useState<string|null>(null)

  async function handleLogin(email: string, password: string) {
    try {
      const res = await axios.post(`${process.env.NEXT_PUBLIC_API_URL}/api/auth/login`, { email, password }, { withCredentials: true })
      if (res.data?.role) {
        router.push(`/dashboard/${res.data.role.toLowerCase()}`)
      } else {
        router.push('/')
      }
    } catch (err: any) {
      setError(err?.response?.data?.message || 'Login failed')
    }
  }

  return (
    <main className="min-h-screen flex items-center justify-center p-4">
      <div className="w-full max-w-md">
        <LoginForm onSubmit={handleLogin} error={error} />
      </div>
    </main>
  )
}
EOF

cat > apps/frontend/pages/dashboard/[role].tsx <<'EOF'
import { useRouter } from 'next/router'
import Layout from '../../components/Layout'
import DashboardWidgets from '../../components/DashboardWidgets'

export default function RoleDashboard({ setTheme, theme }: any) {
  const router = useRouter()
  const { role } = router.query

  return (
    <Layout setTheme={setTheme} theme={theme}>
      <div className="p-6">
        <h2 className="text-2xl font-bold capitalize">{role} Dashboard</h2>
        <DashboardWidgets role={role as string} />
      </div>
    </Layout>
  )
}
EOF

cat > apps/frontend/pages/api/health.ts <<'EOF'
import type { NextApiRequest, NextApiResponse } from 'next'

export default function handler(req: NextApiRequest, res: NextApiResponse) {
  res.status(200).json({ ok: true, version: "1.0.0" })
}
EOF

cat > apps/frontend/components/Layout.tsx <<'EOF'
import Navbar from './Navbar'

export default function Layout({ children, setTheme, theme }: any) {
  return (
    <div>
      <Navbar setTheme={setTheme} theme={theme} />
      <main>{children}</main>
    </div>
  )
}
EOF

cat > apps/frontend/components/Navbar.tsx <<'EOF'
import Link from 'next/link'

export default function Navbar({ setTheme, theme }: any) {
  return (
    <header className="bg-white dark:bg-gray-800 shadow">
      <div className="container mx-auto p-4 flex justify-between items-center">
        <Link href="/" className="font-bold">College</Link>
        <div className="flex items-center gap-3">
          <button
            onClick={() => setTheme(theme === 'dark' ? 'light' : 'dark')}
            className="px-3 py-1 rounded bg-gray-100 dark:bg-gray-700"
          >
            {theme === 'dark' ? 'Light' : 'Dark'}
          </button>
          <Link href="/login" className="px-3 py-1 rounded bg-blue-600 text-white">Login</Link>
        </div>
      </div>
    </header>
  )
}
EOF

cat > apps/frontend/components/LoginForm.tsx <<'EOF'
import { useState } from 'react'

export default function LoginForm({ onSubmit, error }: any) {
  const [email,setEmail]=useState('')
  const [password,setPassword]=useState('')

  return (
    <form onSubmit={e=>{e.preventDefault(); onSubmit(email,password) }} className="bg-white dark:bg-gray-800 p-6 rounded shadow">
      <h3 className="text-lg font-semibold mb-4">Login</h3>
      {error && <div className="text-sm text-red-500 mb-3">{error}</div>}
      <label className="block mb-2">
        <span className="text-sm">Email</span>
        <input value={email} onChange={e=>setEmail(e.target.value)} className="mt-1 block w-full rounded border-gray-200 p-2 bg-transparent" />
      </label>
      <label className="block mb-4">
        <span className="text-sm">Password</span>
        <input type="password" value={password} onChange={e=>setPassword(e.target.value)} className="mt-1 block w-full rounded border-gray-200 p-2 bg-transparent" />
      </label>
      <button type="submit" className="w-full py-2 bg-blue-600 text-white rounded">Sign in</button>
    </form>
  )
}
EOF

cat > apps/frontend/components/DashboardWidgets.tsx <<'EOF'
export default function DashboardWidgets({ role }: any) {
  return (
    <div className="mt-6 grid grid-cols-1 md:grid-cols-3 gap-4">
      <div className="p-4 bg-white dark:bg-gray-800 rounded shadow">
        <h4 className="font-semibold">Quick Attendance</h4>
        <p className="mt-2 text-sm">Take daily attendance with one click.</p>
      </div>
      <div className="p-4 bg-white dark:bg-gray-800 rounded shadow">
        <h4 className="font-semibold">Notices</h4>
        <p className="mt-2 text-sm">Recent notices and announcements.</p>
      </div>
      <div className="p-4 bg-white dark:bg-gray-800 rounded shadow">
        <h4 className="font-semibold">AI Assistant</h4>
        <p className="mt-2 text-sm">Ask study suggestions or exam tips.</p>
      </div>
    </div>
  )
}
EOF

cat > apps/frontend/styles/globals.css <<'EOF'
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Simple dark mode background handling */
html.dark {
  --bg: #0f172a;
}
EOF

cat > apps/frontend/utils/api.ts <<'EOF'
import axios from 'axios'
const api = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_URL || 'http://localhost:4000',
  withCredentials: true
})
export default api
EOF

# apps/backend files
mkdir -p apps/backend/src apps/backend/src/routes apps/backend/src/controllers apps/backend/src/middleware apps/backend/src/services apps/backend/src/lib apps/backend/src/utils

cat > apps/backend/package.json <<'EOF'
{
  "name": "college-backend",
  "version": "1.0.0",
  "main": "dist/index.js",
  "scripts": {
    "dev": "ts-node-dev --respawn --transpile-only src/index.ts",
    "build": "tsc -p .",
    "start": "node dist/index.js",
    "prisma:generate": "prisma generate",
    "prisma:migrate": "prisma migrate dev"
  },
  "dependencies": {
    "@prisma/client": "^5.0.0",
    "bcrypt": "^5.1.0",
    "cookie-parser": "^1.4.6",
    "cors": "^2.8.5",
    "express": "^4.18.2",
    "express-rate-limit": "^6.7.0",
    "helmet": "^7.0.0",
    "jsonwebtoken": "^9.0.0",
    "socket.io": "^4.7.0",
    "stripe": "^12.0.0",
    "node-fetch": "^3.3.2",
    "web-push": "^4.0.0",
    "nodemailer": "^6.9.5",
    "csv-writer": "^1.6.0",
    "pdfkit": "^0.13.0"
  },
  "devDependencies": {
    "@types/express": "^4.17.17",
    "@types/node": "^20.4.0",
    "@types/jsonwebtoken": "^9.0.2",
    "ts-node": "^10.9.1",
    "ts-node-dev": "^2.0.0",
    "typescript": "^5.2.2",
    "prisma": "^5.0.0"
  }
}
EOF

cat > apps/backend/tsconfig.json <<'EOF'
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "CommonJS",
    "outDir": "dist",
    "rootDir": "src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "resolveJsonModule": true
  },
  "exclude": ["node_modules", "dist"]
}
EOF

cat > apps/backend/Dockerfile <<'EOF'
FROM node:20-alpine
WORKDIR /usr/src/app
COPY package.json pnpm-lock.yaml* ./
RUN npm install -g pnpm && pnpm install --frozen-lockfile
COPY . .
RUN pnpm build
EXPOSE 4000
CMD ["node", "dist/index.js"]
EOF

cat > apps/backend/src/config.ts <<'EOF'
export const PORT = process.env.PORT ? Number(process.env.PORT) : 4000;
export const JWT_SECRET = process.env.JWT_SECRET || "dev_jwt_secret";
export const FRONTEND_URL = process.env.FRONTEND_URL || "http://localhost:3000";
export const STRIPE_SECRET_KEY = process.env.STRIPE_SECRET_KEY || "";
export const VAPID_PUBLIC_KEY = process.env.VAPID_PUBLIC_KEY || "";
export const VAPID_PRIVATE_KEY = process.env.VAPID_PRIVATE_KEY || "";
export const OPENAI_API_KEY = process.env.OPENAI_API_KEY || "";
EOF

cat > apps/backend/src/lib/prisma.ts <<'EOF'
import { PrismaClient } from '@prisma/client'
const prisma = new PrismaClient()
export default prisma
EOF

cat > apps/backend/src/index.ts <<'EOF'
import app from './app'
import { PORT } from './config'

app.listen(PORT, () => {
  console.log(`Backend listening on http://localhost:${PORT}`)
})
EOF

cat > apps/backend/src/app.ts <<'EOF'
import express from 'express'
import cors from 'cors'
import helmet from 'helmet'
import cookieParser from 'cookie-parser'
import rateLimit from 'express-rate-limit'
import http from 'http'
import { Server } from 'socket.io'
import authRoutes from './routes/auth'
import usersRoutes from './routes/users'
import studentsRoutes from './routes/students'
import teachersRoutes from './routes/teachers'
import attendanceRoutes from './routes/attendance'
import examsRoutes from './routes/exams'
import paymentsRoutes from './routes/payments'
import notificationsRoutes from './routes/notifications'
import { FRONTEND_URL } from './config'

const app = express()
const server = http.createServer(app)
const io = new Server(server, {
  cors: { origin: FRONTEND_URL, credentials: true }
})

// Simple chat socket for support
io.on('connection', socket => {
  console.log('Socket connected', socket.id)
  socket.on('support:message', (msg) => {
    // relay to admin room, etc
    io.emit('support:message', msg)
  })
})

app.set('io', io)

app.use(helmet())
app.use(express.json())
app.use(cookieParser())
app.use(cors({ origin: FRONTEND_URL, credentials: true }))
app.use(rateLimit({ windowMs: 15 * 60 * 1000, max: 200 }))

app.get('/health', (req, res) => res.json({ ok: true }))

app.use('/api/auth', authRoutes)
app.use('/api/users', usersRoutes)
app.use('/api/students', studentsRoutes)
app.use('/api/teachers', teachersRoutes)
app.use('/api/attendance', attendanceRoutes)
app.use('/api/exams', examsRoutes)
app.use('/api/payments', paymentsRoutes)
app.use('/api/notifications', notificationsRoutes)

export default app
EOF

cat > apps/backend/src/middleware/auth.ts <<'EOF'
import { Request, Response, NextFunction } from 'express'
import jwt from 'jsonwebtoken'
import { JWT_SECRET } from '../config'

export interface AuthRequest extends Request {
  user?: any
}

export function requireAuth(req: AuthRequest, res: Response, next: NextFunction) {
  try {
    const token = req.cookies['token'] || req.headers.authorization?.split(' ')[1]
    if (!token) return res.status(401).json({ message: 'Authentication required' })
    const payload = jwt.verify(token, JWT_SECRET) as any
    req.user = payload
    next()
  } catch (err) {
    return res.status(401).json({ message: 'Invalid or expired token' })
  }
}

export function requireRole(role: string) {
  return function (req: AuthRequest, res: Response, next: NextFunction) {
    if (!req.user) return res.status(401).json({ message: 'Auth required' })
    if (req.user.role !== role && req.user.role !== 'ADMIN') {
      return res.status(403).json({ message: 'Forbidden' })
    }
    next()
  }
}
EOF

cat > apps/backend/src/routes/auth.ts <<'EOF'
import { Router } from 'express'
import { login, logout, me } from '../controllers/authController'
const router = Router()

router.post('/login', login)
router.post('/logout', logout)
router.get('/me', me)

export default router
EOF

cat > apps/backend/src/controllers/authController.ts <<'EOF'
import { Request, Response } from 'express'
import prisma from '../lib/prisma'
import bcrypt from 'bcrypt'
import jwt from 'jsonwebtoken'
import { JWT_SECRET } from '../config'

export async function login(req: Request, res: Response) {
  const { email, password } = req.body
  const user = await prisma.user.findUnique({ where: { email } })
  if (!user) return res.status(401).json({ message: 'Invalid credentials' })

  const isMatch = await bcrypt.compare(password, user.password).catch(()=>false)
  if (!isMatch) {
    return res.status(401).json({ message: 'Invalid credentials' })
  }

  const token = jwt.sign({ id: user.id, email: user.email, role: user.role }, JWT_SECRET, { expiresIn: '7d' })

  res.cookie('token', token, { httpOnly: true, secure: process.env.NODE_ENV === 'production', maxAge: 7*24*3600*1000 })
  res.json({ message: 'ok', role: user.role, name: user.name })
}

export async function logout(req: Request, res: Response) {
  res.clearCookie('token')
  res.json({ message: 'logged out' })
}

export async function me(req: Request, res: Response) {
  try {
    const token = req.cookies['token']
    if (!token) return res.status(200).json({ authenticated: false })
    const payload = jwt.verify(token, JWT_SECRET) as any
    const user = await prisma.user.findUnique({ where: { id: payload.id } })
    res.json({ authenticated: true, user })
  } catch (err) {
    res.status(200).json({ authenticated: false })
  }
}
EOF

cat > apps/backend/src/routes/users.ts <<'EOF'
import { Router } from 'express'
import { requireAuth, requireRole } from '../middleware/auth'
import prisma from '../lib/prisma'
const router = Router()

// Admin creates users
router.post('/', requireAuth, requireRole('ADMIN'), async (req, res) => {
  const { email, password, name, role } = req.body
  const hashed = await require('bcrypt').hash(password, 10)
  const user = await prisma.user.create({ data: { email, password: hashed, name, role } })
  res.json(user)
})

// list users (admin)
router.get('/', requireAuth, requireRole('ADMIN'), async (req, res) => {
  const users = await prisma.user.findMany()
  res.json(users)
})

export default router
EOF

cat > apps/backend/src/routes/students.ts <<'EOF'
import { Router } from 'express'
import { requireAuth } from '../middleware/auth'
import prisma from '../lib/prisma'
const router = Router()

router.get('/:id', requireAuth, async (req, res) => {
  const id = Number(req.params.id)
  const student = await prisma.student.findUnique({ where: { id }, include: { user: true, results: true, attendance: true } })
  res.json(student)
})

// simple admission endpoint
router.post('/admit', requireAuth, async (req, res) => {
  const { email, name, password, rollNumber, batch } = req.body
  const hashed = await require('bcrypt').hash(password, 10)
  const user = await prisma.user.create({ data: { email, name, password: hashed, role: 'STUDENT' } })
  const student = await prisma.student.create({ data: { userId: user.id, rollNumber, batch } })
  res.json({ user, student })
})

export default router
EOF

cat > apps/backend/src/routes/teachers.ts <<'EOF'
import { Router } from 'express'
import { requireAuth, requireRole } from '../middleware/auth'
import prisma from '../lib/prisma'
const router = Router()

router.get('/', requireAuth, requireRole('ADMIN'), async (req, res) => {
  const teachers = await prisma.teacher.findMany({ include: { user: true } })
  res.json(teachers)
})

export default router
EOF

cat > apps/backend/src/routes/attendance.ts <<'EOF'
import { Router } from 'express'
import { requireAuth } from '../middleware/auth'
import prisma from '../lib/prisma'
const router = Router()

// Bulk create attendance for a date
router.post('/bulk', requireAuth, async (req, res) => {
  const { records } = req.body // [{studentId, status}]
  const created = []
  for (const r of records) {
    const c = await prisma.attendance.create({ data: { studentId: r.studentId, status: r.status, date: new Date(r.date || Date.now()) } })
    created.push(c)
  }
  res.json({ created })
})

// Get student attendance summary
router.get('/student/:id', requireAuth, async (req, res) => {
  const id = Number(req.params.id)
  const records = await prisma.attendance.findMany({ where: { studentId: id } })
  res.json(records)
})

export default router
EOF

cat > apps/backend/src/routes/exams.ts <<'EOF'
import { Router } from 'express'
import { requireAuth } from '../middleware/auth'
import prisma from '../lib/prisma'
import { computeGrade } from '../controllers/resultController'
const router = Router()

router.post('/create', requireAuth, async (req, res) => {
  const { title, date, maxMarks } = req.body
  const exam = await prisma.exam.create({ data: { title, date: new Date(date), maxMarks } })
  res.json(exam)
})

// Mark submission & auto result generation
router.post('/submit-marks', requireAuth, async (req, res) => {
  const { examId, marksList } = req.body // [{ studentId, marks }]
  const created = []
  for (const m of marksList) {
    const grade = computeGrade(m.marks)
    const r = await prisma.result.create({ data: { examId, studentId: m.studentId, marks: m.marks, grade } })
    created.push(r)
  }
  res.json({ created })
})

export default router
EOF

cat > apps/backend/src/controllers/resultController.ts <<'EOF'
export function computeGrade(marks: number) {
  if (marks >= 90) return 'A+'
  if (marks >= 80) return 'A'
  if (marks >= 70) return 'B+'
  if (marks >= 60) return 'B'
  if (marks >= 50) return 'C'
  return 'F'
}
EOF

cat > apps/backend/src/routes/payments.ts <<'EOF'
import { Router } from 'express'
import { requireAuth } from '../middleware/auth'
import Stripe from 'stripe'
import { STRIPE_SECRET_KEY } from '../config'
import prisma from '../lib/prisma'
import express from 'express'

const stripe = new Stripe(STRIPE_SECRET_KEY, { apiVersion: '2024-11-01' })

const router = Router()

router.post('/create-session', requireAuth, async (req, res) => {
  const { amount, currency, description } = req.body
  const session = await stripe.checkout.sessions.create({
    payment_method_types: ['card'],
    line_items: [{ price_data: { currency: currency || 'usd', product_data: { name: description || 'College Fee' }, unit_amount: Math.round(amount * 100) }, quantity: 1 }],
    mode: 'payment',
    success_url: `${req.protocol}://${req.get('host')}/payments/success?session_id={CHECKOUT_SESSION_ID}`,
    cancel_url: `${req.protocol}://${req.get('host')}/payments/cancel`,
  })
  res.json({ url: session.url })
})

router.post('/webhook', express.raw({ type: 'application/json' }) as any, async (req: any, res: any) => {
  // Implement webhook signature verification in production
  const event = req.body
  // handle event types to record payments
  res.json({ received: true })
})

export default router
EOF

cat > apps/backend/src/routes/notifications.ts <<'EOF'
import { Router } from 'express'
import webpush from 'web-push'
import { VAPID_PUBLIC_KEY, VAPID_PRIVATE_KEY } from '../config'
const router = Router()

webpush.setVapidDetails('mailto:admin@college.edu', VAPID_PUBLIC_KEY, VAPID_PRIVATE_KEY)

router.post('/subscribe', async (req, res) => {
  const subscription = req.body
  // store subscription in DB for the user
  // send checkbox welcome
  res.json({ success: true })
})

router.post('/send', async (req, res) => {
  const { subscription, payload } = req.body
  try {
    await webpush.sendNotification(subscription, JSON.stringify(payload))
    res.json({ ok: true })
  } catch (err) {
    res.status(500).json({ error: err })
  }
})

export default router
EOF

cat > apps/backend/src/services/mailer.ts <<'EOF'
import nodemailer from 'nodemailer'

export async function sendMail(to: string, subject: string, html: string) {
  // in production configure SMTP, here we provide a dev fallback
  const transporter = nodemailer.createTransport({ jsonTransport: true })
  const info = await transporter.sendMail({ from: 'no-reply@college.edu', to, subject, html })
  return info
}
EOF

cat > apps/backend/src/services/backup.ts <<'EOF'
import { exec } from 'child_process'
import fs from 'fs'
import path from 'path'
export async function backupDatabase(targetDir: string) {
  const ts = new Date().toISOString().replace(/[:.]/g, '-')
  const filename = path.join(targetDir, `backup-${ts}.sql`)
  const cmd = `pg_dump ${process.env.DATABASE_URL} > ${filename}`
  return new Promise((resolve, reject) => {
    exec(cmd, (err) => {
      if (err) return reject(err)
      resolve(filename)
    })
  })
}
EOF

cat > apps/backend/src/services/aiAssistant.ts <<'EOF'
import fetch from 'node-fetch'
import { OPENAI_API_KEY } from '../config'

export async function askAI(prompt: string) {
  // Simple example using OpenAI completion
  const res = await fetch('https://api.openai.com/v1/chat/completions', {
    method: 'POST',
    headers: { Authorization: `Bearer ${OPENAI_API_KEY}`, 'Content-Type': 'application/json' },
    body: JSON.stringify({
      model: "gpt-4o-mini",
      messages: [{ role: 'user', content: prompt }],
      max_tokens: 600
    })
  })
  const data = await res.json()
  return data
}
EOF

cat > apps/backend/src/utils/export.ts <<'EOF'
import { createObjectCsvWriter } from 'csv-writer'
import pdfkit from 'pdfkit'
import fs from 'fs'

export async function exportCSV(headers: any[], records: any[], outPath: string) {
  const writer = createObjectCsvWriter({ path: outPath, header: headers })
  await writer.writeRecords(records)
  return outPath
}

export async function exportPDF(content: string, outPath: string) {
  const doc = new pdfkit()
  doc.pipe(fs.createWriteStream(outPath))
  doc.text(content)
  doc.end()
  return outPath
}
EOF

# scripts/backup.sh
mkdir -p scripts
cat > scripts/backup.sh <<'EOF'
#!/usr/bin/env bash
# Simple backup script: requires pg_dump in PATH
BACKUP_DIR="${BACKUP_DIR:-./backups}"
mkdir -p "$BACKUP_DIR"
TS=$(date +"%Y%m%d-%H%M%S")
pg_dump "$DATABASE_URL" -F c -b -v -f "${BACKUP_DIR}/college-${TS}.dump"
echo "Backup written to ${BACKUP_DIR}/college-${TS}.dump"
EOF
chmod +x scripts/backup.sh

# create_and_push.sh (helper)
cat > create_and_push.sh <<'EOF'
#!/usr/bin/env bash
# create_and_push.sh - uses gh to create repo and push
OWNER="${1:-$OWNER}"
REPO="${2:-$REPO}"
BRANCH="main"

if ! command -v gh >/dev/null 2>&1; then
  echo "gh CLI not installed"
  exit 1
fi
if ! gh auth status >/dev/null 2>&1; then
  echo "gh CLI not authenticated"
  exit 1
fi

git checkout -B "$BRANCH" || true
git add -A
if git diff --cached --quiet; then
  echo "No changes to commit"
else
  git commit -m "Initial commit — College Management System"
fi

set +e
gh repo create "${OWNER}/${REPO}" --public --source=. --remote="origin" --push --confirm
GH_STATUS=$?
set -e

if [ $GH_STATUS -ne 0 ]; then
  echo "gh repo create failed (maybe repo exists). Trying to add remote and push."
  git remote remove origin 2>/dev/null || true
  git remote add origin "git@github.com:${OWNER}/${REPO}.git" 2>/dev/null || git remote add origin "https://github.com/${OWNER}/${REPO}.git"
  git push -u origin "$BRANCH"
fi

echo "Done. Visit: https://github.com/${OWNER}/${REPO}"
EOF
chmod +x create_and_push.sh

# validate_files.sh
cat > validate_files.sh <<'EOF'
#!/usr/bin/env bash
declare -a paths=(
  "README.md"
  ".env.example"
  "docker-compose.yml"
  "prisma/schema.prisma"
  "prisma/seed.ts"
  "apps/frontend/package.json"
  "apps/backend/package.json"
)
MISSING=0
for p in "${paths[@]}"; do
  if [ ! -e "$p" ]; then
    echo "MISSING: $p"
    MISSING=1
  else
    echo "OK:      $p"
  fi
done
if [ $MISSING -ne 0 ]; then
  echo "One or more files are missing."
  exit 2
else
  echo "All required files exist."
fi
EOF
chmod +x validate_files.sh

# .gitignore and LICENSE
cat > .gitignore <<'EOF'
node_modules/
dist/
.env
.env.local
*.log
.vscode/
.DS_Store
EOF

cat > LICENSE <<'EOF'
MIT License

Copyright (c) 2025

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction...
EOF

echo "All files created."

# Run validation
echo
echo "Running validate_files.sh ..."
./validate_files.sh

echo
echo "Initializing git repository (if not already)..."
if [ ! -d .git ]; then
  git init
fi

git checkout -B "$BRANCH" || true
git add -A
if git diff --cached --quiet; then
  echo "No changes to commit."
else
  git commit -m "Initial commit — College Management System"
fi

echo
echo "Attempting to create GitHub repo and push (requires gh auth)..."
set +e
gh repo create "${OWNER}/${REPO}" --public --source=. --remote="origin" --push --confirm
GH_STATUS=$?
set -e

if [ $GH_STATUS -ne 0 ]; then
  echo "gh repo create failed or repo exists. Trying to set remote and push..."
  git remote remove origin 2>/dev/null || true
  # try ssh then https
  if ssh -T git@github.com 2>&1 | grep -q "successfully authenticated"; then
    git remote add origin "git@github.com:${OWNER}/${REPO}.git" || true
  else
    git remote add origin "https://github.com/${OWNER}/${REPO}.git" || true
  fi
  git push -u origin "$BRANCH"
fi

echo
echo "Script finished. If push succeeded, repository is at: https://github.com/${OWNER}/${REPO}"
echo "Next: run 'docker-compose up -d', then 'pnpm install' (repo root), 'cd prisma && pnpm prisma generate', 'npx ts-node prisma/seed.ts', then start backend/frontend."
